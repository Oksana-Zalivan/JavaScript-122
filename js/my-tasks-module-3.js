// 1. 10 вправ по ітеруванню масиву (будь-яким способом)
// У цих завданнях можна використовувати будь-який цикл або метод ітерації: for, for...of, forEach, while тощо.

// Є масив чисел const numbers = [2, 5, 7, 10, 3];
// Пройдися по масиву та виведи в консоль кожен елемент.
// const numbers = [2, 5, 7, 10, 3];
// for (let i = 0; i < numbers.length; i++) {
//     console.log(numbers[i]);
// }


// Є масив чисел const numbers = [1, 4, 9, 16, 25];
// Пройдися по масиву й створи новий масив квадратних коренів цих чисел.
// const numbers = [1, 4, 9, 16, 25];
// const arr = [];
// for (let i = 0; i < numbers.length; i++) {
//     arr.push(Math.sqrt(numbers[i]));
// }
// console.log(arr);


// Є масив рядків ['apple', 'banana', 'kiwi'].
// Пройдися по масиву й виведи довжину кожного слова.
// const fruits = ['apple', 'banana', 'kiwi'];
// for (const fruit of fruits) {
//     console.log(fruit.length);
// }


// Є масив const nums = [10, -3, 5, -7, 0, 12];
// Пройдися по масиву й порахуй суму тільки додатних чисел.
// const nums = [10, -3, 5, -7, 0, 12];
// let sum = 0;
// for (let i = 0; i < nums.length; i++){
//     if (nums[i]>0) {
//         sum += nums[i];
//     }
// }
// console.log(sum);


// Є масив ['JS', 'is', 'awesome'].
// Пройдися по масиву й побудуй один рядок "JS is awesome".
// const arr = ['JS', 'is', 'awesome'];
// const message = arr.join(' ');
// console.log(message);


// Є масив const numbers = [3, 6, 9, 12, 15];
// Пройдися по масиву й створи новий масив, де кожен елемент помножений на 2.
// const numbers = [3, 6, 9, 12, 15];
// const newArr = [];
// for (let i = 0; i < numbers.length; i++){
//     newArr.push(numbers[i] * 2);
// }
// console.log(newArr);


// Є масив ['red', 'green', 'blue', 'yellow'];
// Пройдися по масиву й виведи елементи з їхніми індексами у форматі: "Index 0: red".
// const colors = ['red', 'green', 'blue', 'yellow'];
// for (let i = 0; i < colors.length; i++) {
//     console.log(`Index ${i}: ${colors[i]}`);
// }


// Є масив const prices = [100, 250, 50, 400];
// Пройдися по масиву й створи новий масив цін зі знижкою 20%.
// const prices = [100, 250, 50, 400];
// const discount = 20;
// const newPrices = [];
// for (let i = 0; i < prices.length; i++){
//     newPrices.push(prices[i] - (discount * prices[i] / 100));
// }
// console.log(newPrices);


// Є масив const mixed = [1, 'hello', true, 42, 'js'];
// Пройдися по масиву й створи новий масив тільки з рядками.
// const mixed = [1, 'hello', true, 42, 'js'];
// const arr = [];
// for (let i = 0; i < mixed.length; i++){
//     if (typeof mixed[i] === 'string') {
//         arr.push(mixed[i]);
//     }
// }
// console.log(arr);


// Є масив const nums = [5, 10, 15, 20, 25];
// Пройдися по масиву й знайди найбільше число (без Math.max).
// const nums = [5, 10, 15, 20, 25];
// let max = nums[0];
// for (let i = 0; i < nums.length; i++){
//     if (max < nums[i]) {
//         max = nums[i];
//     }
// }
// console.log(max);



// 2. 10 вправ з циклом for
// У всіх цих завданнях обов’язково використовуй звичайний for.

// Є масив const nums = [1, 2, 3, 4, 5];
// За допомогою for порахуй суму всіх елементів.
// const nums = [1, 2, 3, 4, 5];
// let sum = 0;
// for (let i = 0; i < nums.length; i++){
//     sum += nums[i];
// }
// console.log(sum);


// Є масив ['a', 'b', 'c', 'd'];
// За допомогою for створи новий масив, де кожен елемент буде "letter: a", "letter: b" і т.д.
// const arr = ['a', 'b', 'c', 'd'];
// const newArr = [];
// for (let i = 0; i < arr.length; i++){
//     newArr.push(`letter: ${arr[i]}`);
// }
// console.log(newArr);


// Є масив чисел. Напиши цикл for, який створить новий масив квадратів (num * num) чисел.
// const arr = [1, 5, 8, 4, 3];
// const newArr = [];
// for (let i = 0; i < arr.length; i++){
//     newArr.push(arr[i] ** 2);
// }
// console.log(newArr);


// Є масив const nums = [10, 20, 30, 40, 50];
// За допомогою for виведи кожен другий елемент (індекси 1, 3, ...).
// const nums = [10, 20, 30, 40, 50];
// const newArr = [];
// for (let i = 0; i < nums.length; i++){
//     if (i % 2 !== 0) {
//         newArr.push(nums[i]);
//     }
// }
// console.log(newArr);


// Є масив const nums = [5, 8, 13, 21, 34];
// За допомогою for знайди індекс числа 21 (не використовуй indexOf).
// const nums = [5, 8, 13, 21, 34];
// for (let i = 0; i < nums.length; i++){
//     if (nums[i] === 21) {
//         console.log(i);
//     }
// }


// Є масив const words = ['cat', 'dog', 'elephant', 'fox'];
// За допомогою for створи новий масив з довжинами слів.
// const words = ['cat', 'dog', 'elephant', 'fox'];
// const arr = [];
// for (let i = 0; i < words.length; i++){
//     arr.push(words[i].length);
// }
// console.log(arr);


// Є масив const nums = [2, 4, 6, 8, 10];
// За допомогою for створи новий масив, де кожне число буде рядком: "2px", "4px", ...
// const nums = [2, 4, 6, 8, 10];
// const arr = [];
// for (let i = 0; i < nums.length; i++){
//     arr.push(nums[i] + "px");
// }
// console.log(arr);


// Є масив const nums = [1, 10, 3, 7, 9];
// За допомогою for визнач, чи є в масиві хоча б одне число більше 8 (виведи true/false).
// const nums = [1, 10, 3, 7, 9];
// let res = false;
// for (let i = 0; i < nums.length; i++){
//     if (nums[i] > 8) {
//         res = true;
//     }
// }
// console.log(res);


// Є масив const nums = [1, 2, 3, 4, 5];
// За допомогою for створи новий масив, де елементи йдуть у зворотному порядку.
// const nums = [1, 2, 3, 4, 5];
// const arr = [];
// for (let i = nums.length - 1; i >= 0; i--){
//     arr.push(nums[i]);
// }
// console.log(arr);


// Є масив const nums = [3, 3, 3, 3];
// За допомогою for переконайся, що всі елементи однакові (виведи true/false).
// const nums = [3, 3, 3, 3];
// let res = true;
// for (let i = 0; i < nums.length; i++){
//     if (nums[i] !== nums[0]) {
//         res = false;
//         break;
//     }
// }
// console.log(res);



// 3. 10 вправ з циклом for...of
// У всіх цих завданнях обов’язково використовуй for...of.

// Є масив рядків. За допомогою for...of виведи кожен рядок у верхньому регістрі.
// const names = ['Ксюша', 'Оля', 'Марічка', 'Валентина'];
// const arr = [];
// for (const name of names) {
//     arr.push(name.toUpperCase());
// }
// console.log(arr);


// Є масив чисел. За допомогою for...of порахуй добуток всіх чисел.
// const nums = [5, 8, 4, 3, 7, 9];
// let sum = 1;
// for (const num of nums) {
//     sum *= num;
// }
// console.log(sum);


// Є масив ['js', 'html', 'css'];
// За допомогою for...of створи рядок "js, html, css" (можна без join).
// const arr = ['js', 'html', 'css'];
// let res = "";
// for (const item of arr) {
//     res += item + ", ";
// }
// res = res.slice(0, -2);
// console.log(res);


// Є масив const nums = [10, -5, 0, 7, -2];
// За допомогою for...of створи новий масив тільки з додатними числами.
// const nums = [10, -5, 0, 7, -2];
// const arr = [];
// for (const num of nums) {
//     if (num > 0) {
//         arr.push(num)
//     }
// }
// console.log(arr);


// Є масив рядків. За допомогою for...of знайди найдовше слово.
// const words = ['flower', 'pigeon', 'fox', 'gray', 'transformation'];
// let wordLength = '';
// for (const word of words) {
//     if (word.length > wordLength.length) {
//         wordLength = word;
//     }
// }
// console.log(wordLength);


// Є масив const bools = [true, true, false, true];
// За допомогою for...of перевір, чи є в масиві хоча б один false.
// const bools = [true, true, false, true];
// let res = false;
// for (const bool of bools) {
//     if (bool === false) {
//         res = true;
//         break;
//     }
// }
// console.log(res);


// Є масив const users = ['Olya', 'Max', 'Ira'];
// За допомогою for...of виведи повідомлення "Hello, Olya", "Hello, Max" і т.д.
// const users = ['Olya', 'Max', 'Ira'];
// const arr = [];
// for (const user of users) {
//     arr.push(`Hello, ${user}`,);
// }
// console.log(arr);


// Є масив чисел. За допомогою for...of створи новий масив, де кожне число буде змінено знаком (5 → -5, -3 → 3).
// const nums = [2, -8, 6, 3, -5, -4];
// const arr = [];
// for (const num of nums) {
//     arr.push(num * -1);
// }
// console.log(arr);


// Є масив const nums = [1, 2, 3, 4, 5, 6];
// За допомогою for...of створи новий масив тільки з парними числами.
// const nums = [1, 2, 3, 4, 5, 6];
// const arr = [];
// for (const num of nums) {
//     if (num % 2 === 0) {
//         arr.push(num);
//     }
// }
// console.log(arr);


// Є масив рядків. За допомогою for...of порахуй загальну кількість символів у всіх рядках.
// const words = ["Hello", "my", "dear", "friend"];
// let totalSymbols = 0;
// for (const word of words) {
//     totalSymbols += word.length;
// }
// console.log(totalSymbols);

// 4. 30 вправ по методах масиву
// Методи: join, slice, splice, concat, indexOf, lastIndexOf, split, includes, push, pop, shift, unshift, .length, length - 1.

// Є масив ['I', 'love', 'JS'].
// Використай join, щоб отримати рядок "I love JS".

// Є масив ['apple', 'banana', 'orange', 'kiwi'];
// За допомогою slice створи новий масив тільки з ['banana', 'orange'].

// Є масив ['a', 'b', 'c', 'd'];
// За допомогою splice видали елемент 'c'.

// Є масив ['red', 'green', 'blue']; та ['yellow', 'black'];
// Об’єднай їх в один масив за допомогою concat.

// Є масив ['js', 'html', 'css', 'js'];
// За допомогою indexOf знайди перший індекс 'js'.

// Той самий масив ['js', 'html', 'css', 'js'];
// За допомогою lastIndexOf знайди останній індекс 'js'.

// Є рядок "apple, banana, kiwi"
// Розбий його на масив фруктів за допомогою split.

// Є масив ['cat', 'dog', 'parrot'];
// За допомогою includes перевір, чи є в масиві 'dog'.

// Є масив чисел. За допомогою push додай у кінець нове число й перевір змінену довжину.

// Є масив. За допомогою pop видали останній елемент і збережи його в змінну.

// Є масив. За допомогою shift видали перший елемент і виведи його.

// Є масив. За допомогою unshift додай елемент на початок масиву та виведи нову довжину.

// Напиши код, який, використовуючи .length, виводить останній елемент масиву через індекс length - 1.

// Є масив ['a', 'b', 'c', 'd'];
// За допомогою slice створи копію всього масиву.

// Є масив ['a', 'b', 'c', 'd'];
// За допомогою splice заміни 'b' і 'c' на 'x', 'y'.

// Є два масиви nums1 = [1, 2] та nums2 = [3, 4, 5];
// Об’єднай у один масив і знайди його довжину.

// Є рядок "JS is awesome"
// За допомогою split перетвори його в масив слів, а потім за допомогою join з’єднай назад через '-'.

// Є масив const nums = [1, 2, 3, 4, 5];
// За допомогою slice отримай останні два елементи масиву.

// Є масив const nums = [1, 2, 3, 4, 5];
// За допомогою splice встав у середину (після 2) число 999, не видаляючи елементи.

// Є масив ['html', 'css'];
// Послідовно використай push, щоб додати 'js', 'react', потім pop, щоб забрати останній елемент.
// Перевір, що залишилося.

// Є масив ['apple', 'banana', 'orange'];
// За допомогою includes перевір, чи є 'kiwi', і якщо ні — додай його через push.

// Є рядок "a-b-c-d"
// За допомогою split перетвори в масив, потім за допомогою splice видали 'c', і за допомогою join з’єднай назад.

// Є масив const nums = [1, 2, 3, 4, 5];
// Використай .length, щоб написати цикл, що виводить елементи у зворотному порядку, використовуючи індекс length - 1 - i.

// Є масив ['one', 'two'];
// За допомогою unshift додай 'zero' і перевір, що 'zero' тепер перший елемент.

// Є масив ['x', 'y', 'z', 'y'];
// За допомогою indexOf і lastIndexOf знайди першу і останню позицію 'y'.

// Є масив const nums = [10, 20, 30];
// Напиши код, який видаляє останній елемент без pop, використовуючи тільки .length (зміни значення length).

// Є масив ['red', 'green', 'blue'];
// За допомогою slice зроби новий масив без першого елемента.

// Є масив рядків. За допомогою join створи рядок, у якому елементи будуть розділені переносом рядка ('\n').

// Є масив ['a', 'b', 'c'];
// За допомогою splice видали всі елементи, починаючи з індексу 1.

// Є масив ['js', 'ts']; і рядок "node,react"
// Розбий рядок через split на масив і за допомогою concat об’єднай із першим масивом.




// 5. 10 вправ по псевдомасиву
// Псевдомасиви: arguments, NodeList, HTMLCollection тощо.

// Напиши функцію sum(), яка приймає будь-яку кількість аргументів і через arguments рахує їхню суму.

// У функції logArgs(), виведи всі аргументи в консоль, перетворивши arguments на справжній масив (через Array.from або [...arguments]).

// Напиши функцію, яка повертає масив тільки парних аргументів, використовуючи arguments і ітерацію.

// Уяви, що ти отримала NodeList з document.querySelectorAll('li').
// Напиши псевдокод (без реального DOM), як би ти пройшлася по цьому NodeList і зібрала тексти всіх елементів у масив.

// Напиши функцію toArray(), яка приймає псевдомасив (наприклад, об’єкт з властивостями 0,1,2,length) і повертає справжній масив.

// Напиши функцію firstArg(), яка повертає перший аргумент з arguments або undefined, якщо аргументів немає.

// Напиши функцію, яка за допомогою arguments рахує, скільки рядків було передано як аргументи.

// Напиши функцію, яка приймає будь-яку кількість аргументів і повертає масив довжин усіх рядкових аргументів.

// Напиши функцію, яка з arguments отримує останній аргумент, використовуючи arguments.length - 1.

// Напиши функцію, яка за допомогою arguments перевіряє, чи є серед аргументів хоча б одне число більше 100.




// 6. 10 вправ по області видимості (scope)
// Створи змінну message у глобальній області, а всередині функції створи локальну змінну з таким самим ім’ям.
// Поясни, яке значення буде виведено всередині функції та зовні.

// Напиши приклад з let у блоці if (...) {}, де змінна буде недоступна поза блоком.

// Створи змінну count у глобальній області.
// Напиши функцію, яка збільшує count на 1. Виклич її кілька разів і поясни, як працює доступ до змінної.

// Напиши код з циклом for, у якому лічильник оголошений через var.
// Перевір, чи буде змінна доступна поза циклом.

// Те саме, але з let. Поясни різницю.

// Напиши функцію всередині функції, де внутрішня функція має доступ до змінних зовнішньої (лексичне оточення).
// Опиши, що можна, а що не можна побачити.

// Створи блок if (true) { ... } з змінними var, let, const всередині.
// Перевір, які з них будуть доступні зовні.

// Напиши приклад, де змінна з однаковою назвою існує в глобальній області, в функції та в блоці.
// Простеж, яке значення буде використано де.

// Створи функцію, яка оголошує змінну без ключового слова (x = 10;).
// Перевір, де вона з’явиться (глобальна / локальна) й чому це погано.

// Напиши приклад з двома функціями, де одна функція викликає іншу, а друга намагається прочитати змінну з першої.
// Поясни, чи буде ця змінна доступна.




// 7. 10 вправ по рекурсії
// Напиши рекурсивну функцію, яка рахує факторіал числа n.

// Напиши рекурсивну функцію, яка рахує суму чисел від 1 до n.

// Напиши рекурсивну функцію, яка виводить числа від n до 1 (зворотний відлік).

// Напиши рекурсивну функцію для пошуку елемента в масиві (без indexOf), яка повертає true/false.

// Напиши рекурсивну функцію, яка обчислює n-те число Фібоначчі.

// Напиши рекурсивну функцію, яка приймає масив будь-якої вкладеності (наприклад, [1, [2, [3]], 4]) і рахує суму всіх чисел.

// Напиши рекурсивну функцію, яка приймає рядок і повертає його розвернуту версію (наприклад, "abc" → "cba").

// Напиши рекурсивну функцію, яка виводить усі елементи масиву по одному, не використовуючи циклів.

// Напиши рекурсивну функцію, яка рахує кількість елементів у масиві (не використовуючи .length).

// Напиши рекурсивну функцію, яка перевіряє, чи є в масиві хоча б одне парне число.




// 8. 10 вправ по стеку викликів (call stack)
// Тут важливо зрозуміти порядок виконання функцій.

// Напиши три функції a(), b(), c(), де a викликає b, а b викликає c.
// Додай console.log всередині кожної та поясни, в якому порядку вони будуть з’являтися й як працює стек.

// Створи функцію, яка викликає сама себе без базової умови (нескінченна рекурсія).
// Опиши, що станеться зі стеком викликів (теоретично, не запускаючи реально).

// Напиши функцію outer(), яка викликає inner(), а та викликає ще одну функцію deep().
// Усередині кожної функції виведи свій назву функції.
// Поясни, в якому порядку ці виклики потрапляють у стек.

// Напиши приклад, де одна функція викликає іншу з різними параметрами кілька разів.
// Поясни, як у стеку викликів зберігаються контексти кожного виклику.

// Створи рекурсивну функцію з лічильником глибини викликів (наприклад, параметр depth).
// На кожному кроці виводь "Depth: X".
// Поясни, як збільшується і зменшується стек.

// Напиши код з кількома вкладеними функціями та додай debugger; в одну з них (якби працювала DevTools).
// Теоретично поясни, яку інформацію про стек можна було б побачити.

// Напиши приклад з функціями f1, f2, f3, де f1 викликає f2, f2 викликає f3, а f3 кидає помилку через throw.
// Поясни, як помилка "підіймається" по стеку.

// Напиши приклад із рекурсивною функцією, яка зупиняється після певної глибини (наприклад, if (n === 0) return;).
// Поясни, як стек заповнюється й потім поступово "чиститься".

// Напиши дві функції, які викликають одна одну по черзі (взаємна рекурсія), наприклад fn1 → fn2 → fn1 → ...
// Поясни, чому без умови зупинки стек переповниться.

// Візьми будь-яку зі своїх рекурсивних функцій із попереднього блоку й напиши покроковий опис, що відбувається зі стеком викликів при конкретному значенні аргументу (наприклад, factorial(4)).